def ml_in(name,
          twojmax, rcutfac, wj, radelem, 
          wselfallflag, chemflag, bzeroflag, quadraticflag, bikflag,
          layer_sizes: list, learning_rate, num_epochs, batch_size, multi_element_option,
          n_start, n_end, training_size, testing_size, eweight, fweight):
    with open(f'{name}_ML.in', 'w') as f_in:
        f_in.write('[BISPECTRUM]\n')
        f_in.write('numTypes = 6\n')
        f_in.write(f'twojmax = {twojmax} {twojmax} {twojmax} {twojmax} {twojmax} {twojmax}\n')
        f_in.write(f'rcutfac = {rcutfac}\n')
        f_in.write('rfac0 = 0.99363\n')
        f_in.write('rmin0 = 0.0\n')
        f_in.write(f'wj = {wj} {wj} {wj} {wj} {wj} {wj}\n')
        f_in.write(f'radelem = {radelem} {radelem} {radelem} {radelem} {radelem} {radelem}\n')
        f_in.write('type = Mg O C H CC OO\n')
        f_in.write(f'wselfallflag = {wselfallflag}\n')
        f_in.write(f'chemflag = {chemflag}\n')
        f_in.write(f'bzeroflag = {bzeroflag}\n')
        f_in.write(f'quadraticflag = {quadraticflag}\n')
        f_in.write(f'bikflag = {bikflag}\n')
        f_in.write('dgradflag = 1\n')
        f_in.write('\n')
        f_in.write('[CALCULATOR]\n')
        f_in.write('calculator = LAMMPSSNAP\n')
        f_in.write('energy = 1\n')
        f_in.write('per_atom_energy = 1\n')
        f_in.write('force = 1\n')
        f_in.write('stress = 0\n')
        f_in.write('nonlinear = 1\n')
        f_in.write('\n')
        f_in.write('[ESHIFT]\n')
        f_in.write('Mg = 0.0\n')
        f_in.write('O = 0.0\n')
        f_in.write('C = 0.0\n')
        f_in.write('H = 0.0\n')
        f_in.write('CC = 0.0\n')
        f_in.write('OO = 0.0\n')
        f_in.write('\n')
        f_in.write('[PYTORCH]\n')
        sizes_str = ''
        for size in layer_sizes:
            sizes_str += f'{size} '
        f_in.write(f'layer_sizes = num_desc {sizes_str}1\n')
        f_in.write(f'learning_rate = {learning_rate}\n')
        f_in.write(f'num_epochs = {num_epochs}\n')
        f_in.write(f'batch_size = {batch_size}\n')
        f_in.write('save_state_output = MOF_Pytorch.pt\n')
        f_in.write(f'multi_element_option = {multi_element_option}\n')
        f_in.write('\n')
        f_in.write('[SOLVER]\n')
        f_in.write('solver = PYTORCH\n')
        f_in.write('compute_testerrs = 1\n')
        f_in.write('detailed_errors = 1\n')
        f_in.write('\n')
        f_in.write('[SCRAPER]\n')
        f_in.write('scraper = JSON\n')
        f_in.write('\n')
        f_in.write('[PATH]\n')
        f_in.write('dataPath = ../../data_json\n')
        f_in.write('\n')
        f_in.write('[OUTFILE]\n')
        f_in.write('metrics = MOF_metrics.dat\n')
        f_in.write('potential = MOF_pot\n')
        f_in.write('\n')
        f_in.write('[REFERENCE]\n')
        f_in.write('units = metal\n')
        f_in.write('pair_style = zero 10.0\n')
        f_in.write('pair_coeff = * *\n')
        f_in.write('\n')
        f_in.write('[GROUPS]\n')
        f_in.write('group_sections = name training_size testing_size eweight fweight\n')
        f_in.write('group_types = str float float float float\n')
        f_in.write('smartweights = 0\n')
        f_in.write('random_sampling = 0\n')
        f_in.write(f's{n_start}_e{n_end} = {training_size} {testing_size} {eweight} {fweight}\n')
        f_in.write('\n')
        f_in.write('[EXTRAS]\n')
        f_in.write('dump_peratom = 1\n')
        f_in.write('dump_perconfig = 1\n')
        f_in.write('\n')
        
def ml_sh(name, partition_ML, nodes_ML, ntaskspernode_ML, mem_ML, account_ML, time_ML, np_ML):
    with open(f'{name}_ML.sh', 'w') as f_sh:
        f_sh.write('#!/bin/bash\n')
        f_sh.write(f'#SBATCH --job-name="{name}_ML"\n')
        f_sh.write(f'#SBATCH --output="out.{name}_ML"\n')
        f_sh.write(f'#SBATCH --partition={partition_ML}\n')
        f_sh.write(f'#SBATCH --nodes={nodes_ML}\n')
        f_sh.write(f'#SBATCH --ntasks-per-node={ntaskspernode_ML}\n')
        f_sh.write(f'#SBATCH --mem={mem_ML}G\n')
        f_sh.write(f'#SBATCH --account="{account_ML}"\n')
        f_sh.write('#SBATCH --export=ALL\n')
        f_sh.write(f'#SBATCH -t {time_ML}:00:00\n')
        f_sh.write('\n')
        f_sh.write('module purge\n')
        f_sh.write('module load cpu\n')
        f_sh.write('module load gcc/10.2.0/npcyll4\n')
        f_sh.write('module load openmpi/4.1.1\n')
        f_sh.write('module load slurm\n')
        f_sh.write('\n')
        f_sh.write(f'mpirun -np {np_ML} python -m fitsnap3 {name}_ML.in --overwrite\n')
        f_sh.write('\n')
        
        
def md_in(name, dt, TDAMP, run_steps):
    with open(f'in.{name}', 'w') as f_md:
        f_md.write('#\n')
        f_md.write('\n')
        f_md.write('units           metal\n')
        f_md.write('boundary        p p p\n')
        f_md.write('atom_style      atomic\n')
        f_md.write('neighbor        2.0 bin\n')
        f_md.write('neigh_modify    every 10 delay 0 check no\n')
        f_md.write('read_data	mof_1co2.data\n')
        f_md.write('mass        1 24\n')
        f_md.write('mass        2 16\n')
        f_md.write('mass        3 12\n')
        f_md.write('mass        4 1\n')
        f_md.write('mass        5 12\n')
        f_md.write('mass        6 16\n')
        f_md.write('\n')
        f_md.write('include MOF_pot.mod\n')
        f_md.write('\n')
        f_md.write(f'variable dt equal {dt}\n')
        f_md.write(f'variable TDAMP equal {TDAMP}\n')
        f_md.write('variable TIME equal step*dt # unit: ps\n')
        f_md.write('variable VOL equal vol\n')
        f_md.write('variable PRESS equal press\n')
        f_md.write('variable TEMP equal temp\n')
        f_md.write('variable PotEng equal pe\n')
        f_md.write('\n')
        f_md.write('velocity        all create 300.0 234789\n')
        f_md.write('fix             1 all nvt temp 300.0 300.0 ${TDAMP}\n')
        f_md.write('timestep        ${dt}\n')
        f_md.write('thermo_style    custom step pe ke etotal temp press vol\n')
        f_md.write('thermo          100\n')
        f_md.write(f'dump            1 all custom 100 {name}.dump id type x y z\n')
        f_md.write(f'fix print_vol all print 100 "${{TIME}} ${{PotEng}}" file {name}_output.txt\n')
        f_md.write(f'run {run_steps}\n')
        f_md.write('\n')
        
def md_sh(name, partition_MD, nodes_MD, ntaskspernode_MD, mem_MD, account_MD, time_MD, np_MD):
    with open(f'{name}_MD.sh', 'w') as f_sh:
        f_sh.write('#!/bin/bash\n')
        f_sh.write(f'#SBATCH --job-name="{name}_MD"\n')
        f_sh.write(f'#SBATCH --output="out.{name}_MD"\n')
        f_sh.write(f'#SBATCH --partition={partition_MD}\n')
        f_sh.write(f'#SBATCH --nodes={nodes_MD}\n')
        f_sh.write(f'#SBATCH --ntasks-per-node={ntaskspernode_MD}\n')
        f_sh.write(f'#SBATCH --mem={mem_MD}G\n')
        f_sh.write(f'#SBATCH --account="{account_MD}"\n')
        f_sh.write('#SBATCH --export=ALL\n')
        f_sh.write(f'#SBATCH -t {time_MD}:00:00\n')
        f_sh.write('\n')
        f_sh.write('module purge\n')
        f_sh.write('module load cpu\n')
        f_sh.write('module load gcc/10.2.0/npcyll4\n')
        f_sh.write('module load openmpi/4.1.1\n')
        f_sh.write('module load slurm\n')
        f_sh.write('\n')
        f_sh.write(f'mpirun -np {np_MD} lmp -in in.{name}\n')
        f_sh.write('\n')